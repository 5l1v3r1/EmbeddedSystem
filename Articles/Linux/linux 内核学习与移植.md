# linux 内核学习与移植

标签（空格分隔）： 嵌入式linux

---

## 1. 操作系统基础知识

### 1.1 操作系统的核心功能

- 内存管理

操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要像操作系统去申请和注册，由操作系统的内存管理模块来分配内存给使用，这样的好处是保证内存使用不会冲突。

- 进程调度

进程调度模块负责在各个进程之间进行切换。

- 硬件设备管理

操作系统会去控制各个硬件，应用程序不需要考虑硬件的具体细节，操作系统的硬件设备管理模块就是驱动模块。

- 文件系统

文件系统是管理存储设备的一种方式，存储设备是由多个扇区组成的，有了文件系统之后，人们只关心的文件目录和文件名，而不关心这个文件在物理磁盘的哪个扇区。

### 1.2 操作系统的扩展

- 协议栈

- 有用的应用程序

内核实现操作系统的核心功能，而不包括应用程序，只有内核人事没法用的，因为人做任何事情都是通过相应的应用程序。

### 1.3 内核和驱动的关联

对庞大的整体要有个认识，学习路线就是先建立框架和整体，然后逐渐去学习各个细节部分，逐步细化。

要学着从整体上，从上到下的方式来学习。

注意分层的概念，理解每个东西在哪个层次的哪个地方。

### 1.4 驱动和内核的关系

- 驱动就是内核中的硬件设备管理模块
- 驱动工作在内核态（当前 CPU 正在跑内核代码）

在用户态时，CPU 只能访问允许访问的内存空间。

- 驱动程序故障可能导致整个内核崩溃
- 驱动程序漏洞会使内核不安全

由于应用程序是受限的，所以应用出现问题，不会影响系统中其他应用的运行，系统也不会崩溃。但是如果驱动出错，则可能会导致系统崩溃。

### 1.5 根文件系统

- 为 linux 系统提供根目录，在操作系统中本质上是只有绝对路径的
- 进程 1 存放在根文件系统中，从内核态到用户态的转变，没有根文件系统，就无法转变到用户态
- 内核启动的最后会挂载到根文件系统，根文件系统为操作系统提供根目录

### 1.6 模块化设计

内核中各个功能模块在代码上是彼此独立的，比如调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范 。

- 动态升级（动态的安装和卸载）

模块化的编译和安装，为了操作方便，从静态的升级编程了动态的升级，不需要重启系统或者重新烧录系统，这种动态的升级也是由模块化来升级的。

当需要某个驱动的时候，从硬盘中读取并加载到内存中运行，此时操作系统就能支持该设备的驱动了，当设备关闭或者拔出的时候，需要将该驱动从内存中卸载掉。

模块化的好处：

- 功能可裁剪、灵活
- 可扩展性
- 利于协作

模块化设计是一种普遍性的系统设计原则，例如函数、类，组件，操作系统模块等。

### 1.7 如何选择合适的内核版本

- 并不是越新版本你的内核越好
- 选择 soc 厂家一直的版本会减少工作量

### 1.8 S5PV210 适用的内核版本

- 2.6.35.7 + android2.3 + QT4.8.3
- 3.08 + android 4.0

## 2. linux 内核源码目录

建立整体的框架性概念，整体框架比细节更重要。要注意学习的深度，不必特别详细地分析细节代码。

公共的头文件和架构相关的头文件分开存放，架构相关的在 arch/arm/include 文件夹中，公共的头文件存放在 includes 文件夹中。

- lib
在linux内核编程中是不能用 c 语言标准库函数的，这里面的函数就是供内核调用的库函数。比如在内核中打印时，要用 printk，而不能用 printf，因为 lib 文件夹中没有 printf。

- mm 
内存管理

- net 
tcp ip 协议栈等

- scripts
内核构建相关的脚本

和我们关系比较大的目录有 arch、deiver 目录。

如果 .config 文件中的配置项为 y，则代码会被加入编译，如果为 n，则不会加入编译。如果为 M，则会被编译成 ko 模块。

## 3. 内核启动过程分析

对整个启动过程有所把握。

make O=xxxx/xx/xxx 在指定目录下输出编译后的文件。

?= 如果没有传参定义就按后面配置的来，如果有传参配置定义，就按传参的配置来。

分析链接脚本的目的是找到整个程序的 entry。

kernel的连接脚本并不是直接提供的，而是提供了一个汇编文件vmlinux.lds.S，然后在编译的时候再去编译这个汇编文件得到真正的链接脚本vmlinux.lds。这样可以用条件编译来配置链接脚本。

### 3.1 head.s 分析

内核运行得物理地址为 0x30008000，虚拟地址为 0xC0008000。

把有相同属性的代码放在一个段中，在链接的时候将他们链接到输出文件的指定位置。可以找到该段的起始地址和结束地址，中间的内容就是存放的该段的代码。

内核的起始部分代码是被解压代码调用的。uboot启动内核后实际调用运行的是zImage前面那一段未经压缩的解压代码，解压代码运行时先将 zImage 后段的内核解压开，然后再去调用运行真正的内核入口。

zImage 是压缩后的linux镜像。

内核启动的条件：

- r0 = 0
- r1 = machine nr
- r2 = atags pointer

uboot 最后执行的函数 theKernel 做的事情就是将这三个值放在相应的寄存器中，然后跳转到 kernel 的代码。

在 arm 体系中，函数调用时实际是通过寄存器传参，（函数调用时传参有两种设计：一种是寄存器传参，另一种是用栈内存传参）。

### 3.2 内核启动的汇编阶段

#### 3.2.1 合法性检查

- `__lookup_processor_type`
内核启动前，读出 CPU 的 id 然后和数组中支持的 CPU 进行对比，如果没有一个相等则不合法，如果有一个相等则为合法。

- `__lookup_machine_type`

- `__vet_atags`
检验uboot给内核的传参 ATAGS格式是否正确，这里的传参指的是uboot通过 tag 给内核穿的参数。主要是板子的内存分布 memtag、uboot 的 bootargs。

如果 uboot 给内核传参的部分不对，内核是不会启动的。

#### 3.2.2 建立页表

- `__create_page_tables`
创建页表，因为linux内核被链接在虚拟地址处，因此内核希望尽快建立页表，开启 MMU。

#### 3.2.3 构建 C 语言运行环境

- `__mmap_switched`
复制数据段、清除 BSS 段，构建 C 语言运行环境，保存 CPU ID 号，机器码，tag 传参的首地址。
b start_kernel 跳转到 C 语言运行阶段。

总结：在内核启动的汇编阶段并没有进行太多工作，主要是因为 UBOOT 已经进行了大部分的工作。汇编阶段主要是校验启动合法性、建立段式映射页表并开启 MMU 以方便使用内存，最后跳入 C 语言阶段。

### 3.3 内核启动的C语言阶段

学习思路：

- 抓大放小，不深究
- 重点局部深入分析

学习方法：

- 顺着代码执行路径抓全局
- 对照内核启动的打印信息进行分析

学习路线：

- 分析 uboot 给 kernel 传参的影响和实现
- 硬件初始化与驱动加载
- 内核启动后的结局

#### 3.3.1 machine 查找代码分析
- `setup_processor` 函数用来查找CPU信息，可以结合串口打印的信息来分析

- `setup_machine` 函数的传参是机器码编号，`machine_arch_type` 符号在`include/generated/mach-types.h`的 32039-32050 行定义了。经过分析后确定这个传参值就是2456

- 函数的作用是通过传入的机器码编号，找到对应这个机器码的machine_desc描述符，并且返回这个描述符的指针

- 其实真正干活的函数是 `lookup_machine_type`，找这个函数发现在 head-common.S 中，真正干活的函数是`__lookup_machine_typ`

- `__lookup_machine_typ`函数的工作原理：内核在建立的时候就把各种CPU架构的信息组织成一个一个的machine_desc结构体实例，然后都给一个段属性`.arch.info.init`，链接的时候会保证这些描述符会被连接在一起。`__lookup_machine_type`就去那个那些描述符所在处依次挨个遍历各个描述符，对比查看和哪个机器码相同

#### 3.3.2 cmdline 的传递
`setup_arch` 函数进行了基本的 cmdline 处理：

- cmdline 就是指的 uboot 给 kernel 传参时传递的命令行启动参数，也就是 uboot 的 bootargs。

有几个相关的变量需要注意：

- default_command_line：看名字是默认的命令行参数，实际是一个全局变量字符数组，这个字符数组可以用来存东西

- CONFIG_CMDLINE：在 `.config` 文件中定义的（可以在make menuconfig中去更改设置），这个表示内核的一个默认的命令行参数。

- 内核对cmdline的处理思路
内核中自己维护了一个默认的 cmdline（就是.config中配置的这一个），然后 uboot 还可以通过 tag 给 kernel 再传递一个 cmdline。如果 uboot 给内核传 cmdline 成功则内核会优先使用 uboot 传递的这一个；如果 uboot 没有给内核传 cmdline 或者传参失败，则内核会使用自己默认的这个cmdline。以上说的这个处理思路就是在 setup_arch 函数中实现的。

实验验证内核的cmdline确定：

1. 验证思路：首先给内核配置时配置一个基本的 cmdline，然后在uboot启动内核时给 uboot 设置一个 bootargs，然后启动内核看打印出来的 cmdline 和 uboot 传参时是否一样。

2. 在uboot 中去掉 bootargs，然后再次启动内核看打印出来的 cmdline 是否和内核中设置的默认的 cmdline 一样。

注意：uboot 给内核传递的 cmdline 非常重要，会影响内核的运行，所以要谨慎。有时候内核启动有问题，可以分析下是不是 uboot 的 bootargs 设置不对。

注意：这个传参在这里确定出来之后，后面还会对这个传参进行解析。解析之后 cmdline 中的每一个设置项都会对内核启动有影响。

#### 3.3.3 cmdline 的解析

- setup_command_line
也是在处理和命令行参数cmdline有关的任务。

- parse_early_param&parse_args
解析 cmdline 传参和其他传参，这里的解析意思是把 cmdline 的细节设置信息给解析出来。譬如cmdline：`console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3`，则解析出的内容就是就是一个字符串数组，数组中依次存放了一个设置项目信息。

```
console=ttySAC2,115200  
root=/dev/mmcblk0p2 rw  
init=/linuxrc  
rootfstype=ext3
```

这里只是进行了解析，并没有去处理。也就是说只是把长字符串解析成了短字符串，最多和内核里控制这个相应功能的变量挂钩了，但是并没有去执行。执行的代码在各自模块初始化的代码部分。

#### 3.3.3 start_kernel 中的其他函数
- trap_init					设置异常向量表
- mm_init				     内存管理模块初始化
- sched_init			        内核调度系统初始化
- early_irq_init&init_IRQ	       中断初始化
- console_init				控制台初始化

总结：start_kernel函数中调用了很多的xx_init函数，全都是内核工作需要的模块的初始化函数。这些初始化之后内核就具有了一个基本的可以工作的条件了。

如果把内核比喻成一个复杂机器，那么 start_kernel 函数就是把这个机器的众多零部件组装在一起形成这个机器，让他具有可以工作的基本条件。

- rest_init
这个函数之前内核的基本组装已经完成，剩下的一些工作就比较重要了，放在了一个单独的函数中，叫 rest_init。

总结：start_kernel函数做的主要工作：打印了一些信息、内核工作需要的模块的初始化被依次调用（譬如内存管理、调度系统、异常处理···）、需要重点了解的就是 setup_arch 中做的2件事情：机器码架构的查找并且执行架构相关的硬件的初始化、uboot 给内核的传参 cmdline。