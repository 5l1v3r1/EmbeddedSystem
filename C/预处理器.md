# 预处理器
编译一个 C 程序设计很多步骤。其中第 1 个步骤被称为预处理阶段。C 预处理器在源代码编译之前对其进行一些文本性质的操作。他的主要任务包括删除注释、插入被 #include 指令包含的文件的内容、定义、和替换由 #define 指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。

## 预定义符号

1.预处理器定义了一些符号，他们的值或者是字符串常量，或者是十进制数字常量，__FILE__的含义是进行编译的源文件名。

 ![img](assets/wps3485.tmp.jpg) 

## #define   

## 条件编译

##  文件包含

## 其他指令

### `#error` 指令允许生成错误信息

```c
#error text of error message
```


使用方法：
```c
#error no option selsected
```

### `#line` 修改下一行输入的行号
```c
#line number "string"
```

它通知预处理器 number 使下一行输入的行号。如果给出了可选部分 string ，预处理器就把他当作当前文件的名字。值得注意的是，这条指令修改 `__LINE__`符号的值，如果加上可选部分，他还将修改`__FILE__`符号的值。 

### `#progma` 用于支持因编译器而异的特性

`#progma` 指令是另一种机制，用于支持因编译器而异的机制。它的语法也是因编译器而异。有些环境可能提供一些`#progma`指令，允许一些编译选项或者其他任何任何方式无法实现的一些处理方式。例如有些编译器使用`progma`指令在编译过程中打开或者关闭清单显示，或者把会变代码插入到 C 程序中。从本质上说，`#progma`是不可移植的。预处理器将忽略他们不认识的`#progma` 指令，两个不同的编译器可能以两种不同的方式解释同一条`#progma`指令。

### `#`(null directive) 无效指令

无效指令就是一个`#`开头，但后面不跟任何内容的一行。这类指令只是被预处理器简单地删除。下面地例子中无效指令通过把 `#include`与周围的代码分隔开来，凸显它的存在。

```
#
#include <stdio.h>
#
```

插入空行也可以取得相同的效果。


## 总结

## 警告的总结

1. 不要在一个宏定义的末尾加上分号，使其成为一条完整的语句。
2. 在宏定义中使用参数，但忘了在他们周围加上括号。
3. 忘了在整个宏定义的两边加上括号。

## 编程提示的总结

1. 避免用 #define 指令定义可以用函数实现的很长序列的代码。
2. 在那些对表达式求值的宏中，每个宏参数出现的地方都应该加上括号，并且在整个宏定义的两边也加上括号。
3. 避免使用 #define 宏创建一种新的语言。
4. 采用采用命名约定，使程序员很容易看出某个标识符是否为 #define 宏。
5. 只要合适就应该使用文件包含，不必担心它的额外开销。
6. 头文件只应该包含一组函数和（或）数据的声明。
7. 把不同集合的声明分离到不同的头文件中可以改善信息隐藏。
8. 嵌套的 #include  文件是我们很难判断源文件之间的依赖关系。
```

```