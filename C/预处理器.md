# 预处理器
编译一个 C 程序设计很多步骤。其中第 1 个步骤被称为预处理阶段。C 预处理器在源代码编译之前对其进行一些文本性质的操作。他的主要任务包括删除注释、插入被 #include 指令包含的文件的内容、定义、和替换由 #define 指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译。

## 预定义符号

1.预处理器定义了一些符号，他们的值或者是字符串常量，或者是十进制数字常量，__FILE__的含义是进行编译的源文件名。

 ![img](assets/wps3485.tmp.jpg) 

## #define  

### 宏
`#define` 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏（defined macro）。下面是宏的声明方式：
```c
#define name(parameter-list) stuff
```
其中，parameter-list（参数列表）是一个由都好分隔的值的列表，每个值都与宏定义中的一个参数相对应，整个列表用一对括号包围。当参数出现在程序中时，与每个参数对应的实际值都将被替换到 stuff 中。

这里由一个宏。它接受一个参数：
```c
#define SQUARE(x)  ((x) * (x))
```

如果在上述声明之后把 `SQUARE(5)`至于程序中，预处理器就会用下面的这个表达式替换上面的表达式：
```
((5)*(5))
```
这里添加括号的原因是，为了避免在使用宏时，由于参数中的操作符或邻近的操作符之间不可预料的相互作用。

### #define 替换

在程序中扩展`#define`定义符号和宏时，需要涉及几个步骤。

1. 在调用宏时，首先对参数进行检查，看看是否包含了任何由`#define`定义的符号。如果是，他们首先被替换。
2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替代。
3. 最后，再次对结果文本进行扫描，看看他是否包含了任何由`#define`定义的符号。如果是，就重复上述处理过程。

这样，宏参数和`#define`定义可以包含其他`#define`定义的符号。但是，宏不可以出现递归。

#### #argument 替换符号
当预处理器搜索`#define`定义的符号时，字符串常量的内容并不进行检查。`#argument` 这种结构被预处理器翻译为 "argument"，可以把一个宏参数转化为字符串。如果想把宏参数插入到字符串常量中，可以使用下面的技巧：

##### 技巧一
首先，临近字符串自动连接的特性使我们很容易把一个字符串分成几段，每段实际上都是一个宏参数。例子如下：
```c
#define PRINT(FORMAT,VALUE)  \
printf( "The value is "#FORMAT"", VALUE)
...
int x = 6;
PRINT_FOR( %d, x + 3);
```
输出结果：
```
The value is 9
```

##### 技巧二

```c
#define PRINT_FOR(FORMAT, VALUE) \
        printf("the value of     \
        "#VALUE" is "#FORMAT" \n",VALUE) 
...
PRINT_FOR( %d, x + 3);
```
输出结果：
```
the value of x + 3 is 9 
```

书上的技巧一和技巧二并不能通过编译，我经过修改的到上面的两个例子，我感觉是用了同一个技巧就是将字符串中的 `"#VALUE"` 替换成传入的字符，如技巧二中介绍的将 `#VALUE`替换成了字符串中的 x+3，将 `#FORMAT` 替换成 %d，最后一个 VALUE 作为实际的参数只是进行了简单的文本替换，不涉及字符串修改。

##### 技巧三
```
#define PRINT(VALUE)  printf(#VALUE)
...
PRINT(hello SummerGift);
```
输出结果：
```
hello SummerGift
```

技巧三展示了基本的 `#argument`功能，即将 `#VALUE`替换成 `"hello SummerGift"`，也就是将 hello SummerGift 简单替换成了 "hello SummerGift"。

#### ##连接符号
`##` 结构把位于它两边的符号连接成一个符号。作为用途之一，它允许宏定义从分离的文本片段创建标识符。下面的这个例子使用这种连接把一个值添加到几个变量之一：

```c
#define ADD_TO_SUM( sum_number, value) \
        sum ## sum_number += value
...
ADD_TO_SUM(5, 25);
```

最后一条语句把值25加到变量 sum5。注意这种连接必须产生一个合法的标识符。否则其结果就是未定义的。



## 条件编译

##  文件包含

## 其他指令

### `#error` 指令允许生成错误信息

```c
#error text of error message
```


使用方法：
```c
#error no option selsected
```

### `#line` 修改下一行输入的行号
```c
#line number "string"
```

它通知预处理器 number 使下一行输入的行号。如果给出了可选部分 string ，预处理器就把他当作当前文件的名字。值得注意的是，这条指令修改 `__LINE__`符号的值，如果加上可选部分，他还将修改`__FILE__`符号的值。 

### `#progma` 用于支持因编译器而异的特性

`#progma` 指令是另一种机制，用于支持因编译器而异的机制。它的语法也是因编译器而异。有些环境可能提供一些`#progma`指令，允许一些编译选项或者其他任何任何方式无法实现的一些处理方式。例如有些编译器使用`progma`指令在编译过程中打开或者关闭清单显示，或者把会变代码插入到 C 程序中。从本质上说，`#progma`是不可移植的。预处理器将忽略他们不认识的`#progma` 指令，两个不同的编译器可能以两种不同的方式解释同一条`#progma`指令。

### `#`(null directive) 无效指令

无效指令就是一个`#`开头，但后面不跟任何内容的一行。这类指令只是被预处理器简单地删除。下面地例子中无效指令通过把 `#include`与周围的代码分隔开来，凸显它的存在。

```
#
#include <stdio.h>
#
```

插入空行也可以取得相同的效果。


## 总结

## 警告的总结

1. 不要在一个宏定义的末尾加上分号，使其成为一条完整的语句。
2. 在宏定义中使用参数，但忘了在他们周围加上括号。
3. 忘了在整个宏定义的两边加上括号。

## 编程提示的总结

1. 避免用 #define 指令定义可以用函数实现的很长序列的代码。
2. 在那些对表达式求值的宏中，每个宏参数出现的地方都应该加上括号，并且在整个宏定义的两边也加上括号。
3. 避免使用 #define 宏创建一种新的语言。
4. 采用采用命名约定，使程序员很容易看出某个标识符是否为 #define 宏。
5. 只要合适就应该使用文件包含，不必担心它的额外开销。
6. 头文件只应该包含一组函数和（或）数据的声明。
7. 把不同集合的声明分离到不同的头文件中可以改善信息隐藏。
8. 嵌套的 #include  文件是我们很难判断源文件之间的依赖关系。